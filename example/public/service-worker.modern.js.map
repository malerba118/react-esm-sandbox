{"version":3,"file":"service-worker.modern.js","sources":["../../node_modules/promise-worker/register.js","../../src/interpreter/types.ts","../../src/interpreter/service-worker.ts"],"sourcesContent":["'use strict'\n\nfunction isPromise (obj) {\n  // via https://unpkg.com/is-promise@2.1.0/index.js\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function'\n}\n\nfunction registerPromiseWorker (callback) {\n  function postOutgoingMessage (e, messageId, error, result) {\n    function postMessage (msg) {\n      /* istanbul ignore if */\n      if (typeof self.postMessage !== 'function') { // service worker\n        e.ports[0].postMessage(msg)\n      } else { // web worker\n        self.postMessage(msg)\n      }\n    }\n    if (error) {\n      /* istanbul ignore else */\n      if (typeof console !== 'undefined' && 'error' in console) {\n        // This is to make errors easier to debug. I think it's important\n        // enough to just leave here without giving the user an option\n        // to silence it.\n        console.error('Worker caught an error:', error)\n      }\n      postMessage([messageId, {\n        message: error.message\n      }])\n    } else {\n      postMessage([messageId, null, result])\n    }\n  }\n\n  function tryCatchFunc (callback, message) {\n    try {\n      return { res: callback(message) }\n    } catch (e) {\n      return { err: e }\n    }\n  }\n\n  function handleIncomingMessage (e, callback, messageId, message) {\n    var result = tryCatchFunc(callback, message)\n\n    if (result.err) {\n      postOutgoingMessage(e, messageId, result.err)\n    } else if (!isPromise(result.res)) {\n      postOutgoingMessage(e, messageId, null, result.res)\n    } else {\n      result.res.then(function (finalResult) {\n        postOutgoingMessage(e, messageId, null, finalResult)\n      }, function (finalError) {\n        postOutgoingMessage(e, messageId, finalError)\n      })\n    }\n  }\n\n  function onIncomingMessage (e) {\n    var payload = e.data\n    if (!Array.isArray(payload) || payload.length !== 2) {\n      // message doens't match communication format; ignore\n      return\n    }\n    var messageId = payload[0]\n    var message = payload[1]\n\n    if (typeof callback !== 'function') {\n      postOutgoingMessage(e, messageId, new Error(\n        'Please pass a function into register().'))\n    } else {\n      handleIncomingMessage(e, callback, messageId, message)\n    }\n  }\n\n  self.addEventListener('message', onIncomingMessage)\n}\n\nmodule.exports = registerPromiseWorker\n","export type SourceFiles = Record<string, SourceFile>\n\nexport type SourceFile = {\n  contents: string\n}\n\nexport enum InterpreterEventType {\n  FilesUpdated = 'FilesUpdated',\n  Unmounted = 'Unmounted'\n}\n","import registerPromiseWorker from 'promise-worker/register'\nimport { InterpreterEventType } from './types'\n\nconst sw: any = self\n\nlet interpreterSourceFiles = {}\n\nregisterPromiseWorker(({ interpreterId, type, payload }) => {\n  if (type === InterpreterEventType.FilesUpdated) {\n    interpreterSourceFiles[interpreterId] = payload\n  }\n})\n\nsw.addEventListener('install', function () {\n  sw.skipWaiting()\n})\n\nsw.addEventListener('fetch', function (event: any) {\n  Object.keys(interpreterSourceFiles).forEach((interpreterId) => {\n    Object.keys(interpreterSourceFiles[interpreterId]).forEach((filePath) => {\n      if (event.request.url.endsWith(`${interpreterId}/${filePath}`)) {\n        event.respondWith(\n          new Response(\n            interpreterSourceFiles[interpreterId][filePath].contents,\n            {\n              headers: { 'Content-Type': 'application/javascript' }\n            }\n          )\n        )\n      }\n    })\n  })\n})\n"],"names":["InterpreterEventType","sw","self","interpreterSourceFiles","callback","postOutgoingMessage","e","messageId","error","result","postMessage","msg","ports","console","message","addEventListener","payload","data","Array","isArray","length","obj","res","err","tryCatchFunc","then","finalResult","finalError","handleIncomingMessage","registerPromiseWorker","interpreterId","type","FilesUpdated","skipWaiting","event","Object","keys","forEach","filePath","request","url","endsWith","respondWith","Response","contents","headers","Content-Type"],"mappings":"AA6EA,ICvEYA,GAAZ,SAAYA,GACVA,8BACAA,wBAFF,CAAYA,IAAAA,OCHZ,MAAMC,EAAUC,KAEhB,IAAIC,EAAyB,IFE7B,SAAgCC,GAC9B,SAASC,EAAqBC,EAAGC,EAAWC,EAAOC,GACjD,SAASC,EAAaC,GAEY,mBAArBT,KAAKQ,YACdJ,EAAEM,MAAM,GAAGF,YAAYC,GAEvBT,KAAKQ,YAAYC,GAGjBH,GAEqB,oBAAZK,SAA2B,UAAWA,SAI/CA,QAAQL,MAAM,0BAA2BA,GAE3CE,EAAY,CAACH,EAAW,CACtBO,QAASN,EAAMM,YAGjBJ,EAAY,CAACH,EAAW,KAAME,IA6ClCP,KAAKa,iBAAiB,UAjBtB,SAA4BT,GAC1B,IAAIU,EAAUV,EAAEW,KACXC,MAAMC,QAAQH,IAA+B,IAAnBA,EAAQI,QAlBzC,SAAgCd,EAAGF,EAAUG,EAAWO,GACtD,IAxCgBO,EAwCZZ,EATN,SAAuBL,EAAUU,GAC/B,IACE,MAAO,CAAEQ,IAAKlB,EAASU,IACvB,MAAOR,GACP,MAAO,CAAEiB,IAAKjB,IAKHkB,CAAapB,EAAUU,GAEhCL,EAAOc,IACTlB,EAAoBC,EAAGC,EAAWE,EAAOc,OA3C3BF,EA4CMZ,EAAOa,MA1CC,iBAARD,GAAmC,mBAARA,GAA2C,mBAAbA,EAAII,KA2CjFpB,EAAoBC,EAAGC,EAAW,KAAME,EAAOa,KAE/Cb,EAAOa,IAAIG,KAAK,SAAUC,GACxBrB,EAAoBC,EAAGC,EAAW,KAAMmB,IACvC,SAAUC,GACXtB,EAAoBC,EAAGC,EAAWoB,KAkBpCC,CAAsBtB,EAAGF,EAPXY,EAAQ,GACVA,EAAQ,OEzD1Ba,CAAsB,EAAGC,cAAAA,EAAeC,KAAAA,EAAMf,QAAAA,MACxCe,IAAS/B,EAAqBgC,eAChC7B,EAAuB2B,GAAiBd,KAI5Cf,EAAGc,iBAAiB,UAAW,WAC7Bd,EAAGgC,gBAGLhC,EAAGc,iBAAiB,QAAS,SAAUmB,GACrCC,OAAOC,KAAKjC,GAAwBkC,QAASP,IAC3CK,OAAOC,KAAKjC,EAAuB2B,IAAgBO,QAASC,IACtDJ,EAAMK,QAAQC,IAAIC,YAAYX,KAAiBQ,MACjDJ,EAAMQ,YACJ,IAAIC,SACFxC,EAAuB2B,GAAeQ,GAAUM,SAChD,CACEC,QAAS,CAAEC,eAAgB"}